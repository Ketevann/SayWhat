{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap dd726ff3fdab54d517a8","webpack:///./src/constants.js","webpack:///./src/Cache.js","webpack:///./src/utils.js","webpack:///./src/index.js"],"names":["INFINITY","Number","POSITIVE_INFINITY","INVALID_FIRST_PARAMETER_ERROR","NO_PROMISE_LIBRARY_EXISTS_ERROR_MESSAGE","ITERATOR_DONE_OBJECT","done","CACHE_IDENTIFIER","Symbol","ARRAY_OBJECT_CLASS","FUNCTION_TYPEOF","FUNCTION_NAME_REGEXP","OBJECT_TYPEOF","GOTCHA_OBJECT_CLASSES","Boolean","Date","RegExp","String","STATIC_PROPERTIES_TO_PASS","STATIC_PROPERTIES_TO_PASS_LENGTH","length","Cache","lastItem","undefined","list","size","clear","setLastItem","delete","key","index","getIndexOfKey","splice","get","value","item","unshift","getKeyIterator","next","isMultiParamKey","has","set","updateItem","jsonStringify","JSON","stringify","keys","Object","toString","prototype","addStaticPropertiesToFunction","originalFunction","memoizedFn","property","compose","functions","reduce","f","g","every","array","fn","startingIndex","isCache","object","createCurriableOptionMethod","option","createPluckFromInstanceList","cache","map","getFunctionNameViaRegexp","match","getFunctionName","displayName","name","isArrayFallback","call","isArray","Array","isComplexObject","isFunction","isPlainObject","constructor","isValueObjectOrArray","Class","customReplacer","decycle","coalesceCircularReferences","path","$ref","itemIndex","deleteItemFromCache","isKeyLastItem","isKeyShallowEqualWithArgs","args","arg","getMultiParamKey","iterator","iteration","createAddPropertiesToFunction","options","isMemoized","add","values","isFiniteAndPositive","number","replacer","exception","getStringifiedArgument","createArgumentSerializer","serializeFunctions","maxArgs","hasMaxArgs","getSerializerFunction","serializerFromOptions","createGetCacheKey","serialize","serializeArguments","slice","createSetExpirationOfCache","maxAge","setTimeout","createPromiseRejecter","PromiseLibrary","reject","createPromiseResolver","hasMaxAge","setExpirationOfCache","resolvedValue","resolve","createSetNewCachedValue","isPromise","maxSize","hasMaxSize","promiseResolver","promiseRejecter","handler","then","PROMISE_OPTIONS","REACT_OPTIONS","SERIALIZE_OPTIONS","moize","functionOrComposableOptions","passedOptions","otherOptions","TypeError","isComposed","promiseLibrary","Promise","serializer","ReferenceError","addPropertiesToFunction","getCacheKey","setNewCachedValue","memoizedFunction","apply","promise","react","simple"],"mappings":"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","file":"moize.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"moize\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"moize\"] = factory();\n\telse\n\t\troot[\"moize\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap dd726ff3fdab54d517a8","// types\nimport type{\n  IteratorDone\n} from './types';\n\n/**\n * @private\n *\n * @constant {number} INFINITY\n * @default\n */\nexport const INFINITY: number = Number.POSITIVE_INFINITY;\n\n/**\n * @private\n *\n * @constant {string} INVALID_FIRST_PARAMETER_ERROR\n * @default\n */\nexport const INVALID_FIRST_PARAMETER_ERROR: string = 'You must pass either a function or an object of options as the first parameter to moize.';\n\n/**\n * @private\n *\n * @constant {string} NO_PROMISE_LIBRARY_EXISTS_ERROR_MESSAGE\n * @default\n */\nexport const NO_PROMISE_LIBRARY_EXISTS_ERROR_MESSAGE: string = 'You have not specified a promiseLibrary, and it appears that your browser does not support ' +\n  'native promises. You can either assign the library you are using to the global Promise object, or pass ' +\n  'the library in options via the \"promiseLibrary\" property.';\n\n/**\n * @private\n *\n * @constant {IteratorDone} ITERATOR_DONE_OBJECT\n */\nexport const ITERATOR_DONE_OBJECT: IteratorDone = {\n  done: true\n};\n\n/**\n * @private\n *\n * @constant {string|symbol} CACHE_IDENTIFIER\n * @default\n */\nexport const CACHE_IDENTIFIER: (string|Symbol) = typeof Symbol === 'function' ? Symbol('isMoizeCache') : '__IS_MOIZE_CACHE__';\n\n/**\n * @private\n *\n * @constant {string} ARRAY_OBJECT_CLASS\n * @default\n */\nexport const ARRAY_OBJECT_CLASS: string = '[object Array]';\n\n/**\n * @private\n *\n * @constant {string} FUNCTION_TYPEOF\n * @default\n */\nexport const FUNCTION_TYPEOF: string = 'function';\n\n/**\n * @private\n *\n * @constant {RegExp} FUNCTION_NAME_REGEXP\n */\nexport const FUNCTION_NAME_REGEXP: RegExp = /^\\s*function\\s+([^\\(\\s]*)\\s*/;\n\n/**\n * @private\n *\n * @constant {string} OBJECT_TYPEOF\n * @default\n */\nexport const OBJECT_TYPEOF: string = 'object';\n\n/**\n * @private\n *\n * @constant {Array<Object>} GOTCHA_OBJECT_CLASSES\n */\nexport const GOTCHA_OBJECT_CLASSES: Array<Object> = [\n  Boolean,\n  Date,\n  Number,\n  RegExp,\n  String\n];\n\n/**\n * @private\n *\n * @constant {Array<string>} STATIC_PROPERTIES_TO_PASS\n */\nexport const STATIC_PROPERTIES_TO_PASS: Array<string> = [\n  'contextTypes',\n  'defaultProps',\n  'propTypes'\n];\n\n/**\n * @private\n *\n * @constant {number} STATIC_PROPERTIES_TO_PASS_LENGTH\n */\nexport const STATIC_PROPERTIES_TO_PASS_LENGTH: number = STATIC_PROPERTIES_TO_PASS.length;\n\n\n\n// WEBPACK FOOTER //\n// ./src/constants.js","// @flow\n\n\n// constants\nimport {\n  CACHE_IDENTIFIER,\n  ITERATOR_DONE_OBJECT\n} from './constants';\n\n// types\nimport type {\n  IteratorDone,\n  KeyIterator,\n  ListItem\n} from './types';\n\n// utils\nimport {\n  getIndexOfKey,\n  splice,\n  unshift\n} from './utils';\n\n/**\n * @class Cache\n * @classdesc class that mimics parts of the Map infrastructure, but faster\n */\nclass Cache {\n  // $FlowIgnore computed properties not yet supported on classes\n  [CACHE_IDENTIFIER]: boolean = true;\n\n  lastItem: ?ListItem = undefined;\n  list: Array<ListItem> = [];\n  size: number = 0;\n\n  /**\n   * @function clear\n   * @memberof Cache\n   * @instance\n   *\n   * @description\n   * remove all keys from the map\n   */\n  clear(): void {\n    this.list.length = 0;\n\n    this.setLastItem();\n  }\n\n  /**\n   * @function delete\n   * @memberof Cache\n   * @instance\n   *\n   * @description\n   * remove the key from the map\n   *\n   * @param {*} key key to delete from the map\n   */\n  delete(key: any): void {\n    const index: number = getIndexOfKey(this, key);\n\n    if (~index) {\n      splice(this.list, index);\n\n      this.setLastItem(this.list[0]);\n    }\n  }\n\n  /**\n   * @function get\n   * @memberof Cache\n   * @instance\n   *\n   * @description\n   * get the value for the given key\n   *\n   * @param {*} key key to get the value for\n   * @returns {*} value at the key location\n   */\n  get(key: any): any {\n    if (!this.lastItem) {\n      return undefined;\n    }\n\n    if (key === this.lastItem.key) {\n      return this.lastItem.value;\n    }\n\n    const index: number = getIndexOfKey(this, key);\n\n    if (~index) {\n      const item: ListItem = this.list[index];\n\n      this.setLastItem(unshift(splice(this.list, index), item));\n\n      return item.value;\n    }\n  }\n\n  /**\n   * @function getKeyIterator\n   * @memberof Cache\n   * @instance\n   *\n   * @description\n   * create a custom iterator for the keys in the list\n   *\n   * @returns {{next: (function(): Object)}} iterator instance\n   */\n  getKeyIterator(): KeyIterator {\n    let index: number = -1;\n\n    return {\n      next: (): (ListItem|IteratorDone) => {\n        return ++index >= this.size ? ITERATOR_DONE_OBJECT : {\n          index,\n          isMultiParamKey: this.list[index].isMultiParamKey,\n          key: this.list[index].key\n        };\n      }\n    };\n  }\n\n  /**\n   * @function has\n   * @memberof Cache\n   * @instance\n   *\n   * @description\n   * does the map have the key provided\n   *\n   * @param {*} key key to test for in the map\n   * @returns {boolean} does the map have the key\n   */\n  has(key: any): boolean {\n    // $FlowIgnore: this.lastItem exists\n    return this.size !== 0 && (key === this.lastItem.key || !!~getIndexOfKey(this, key));\n  }\n\n  /**\n   * @function set\n   * @memberof Cache\n   * @instance\n   *\n   * @description\n   * set the value at the key location, or add a new item with that key value\n   *\n   * @param {*} key key to assign value of\n   * @param {*} value value to store in the map at key\n   */\n  set(key: any, value: any): void {\n    this.setLastItem(unshift(this.list, {\n      key,\n      isMultiParamKey: !!(key && key.isMultiParamKey),\n      value\n    }));\n  }\n\n  /**\n   * @function setLastItem\n   * @memberof Cache\n   * @instance\n   *\n   * @description\n   * assign the lastItem\n   *\n   * @param {ListItem|undefined} lastItem the item to assign\n   */\n  setLastItem(lastItem: ?ListItem): void {\n    this.lastItem = lastItem;\n    this.size = this.list.length;\n  }\n\n  /**\n   * @function updateItem\n   * @memberof Cache\n   * @instance\n   *\n   * @description\n   * update an item in-place with a new value\n   *\n   * @param {*} key key to update value of\n   * @param {*} value value to store in the map at key\n   */\n  updateItem(key: any, value: any): void {\n    const index: number = getIndexOfKey(this, key);\n\n    if (~index) {\n      this.list[index].value = value;\n\n      if (this.lastItem && key === this.lastItem.key) {\n        this.lastItem.value = value;\n      }\n    }\n  }\n}\n\nexport default Cache;\n\n\n\n// WEBPACK FOOTER //\n// ./src/Cache.js","// @flow\n\n// cache\nimport Cache from './Cache';\n\n// constants\nimport {\n  ARRAY_OBJECT_CLASS,\n  CACHE_IDENTIFIER,\n  FUNCTION_TYPEOF,\n  FUNCTION_NAME_REGEXP,\n  GOTCHA_OBJECT_CLASSES,\n  OBJECT_TYPEOF,\n  STATIC_PROPERTIES_TO_PASS,\n  STATIC_PROPERTIES_TO_PASS_LENGTH\n} from './constants';\n\n// types\nimport type {\n  KeyIterator,\n  ListItem,\n  Options\n} from './types';\n\nexport const jsonStringify: Function = JSON.stringify;\nexport const keys: Function = Object.keys;\nexport const toString: Function = Object.prototype.toString;\n\n/**\n * @private\n *\n * @function addStaticPropertiesToFunction\n *\n * @description\n * add static properties to the memoized function if they exist on the original\n *\n * @param {function} originalFunction the function to be memoized\n * @param {function} memoizedFn the higher-order memoized function\n * @returns {function} memoizedFn with static properties added\n */\nexport const addStaticPropertiesToFunction = (originalFunction: Function, memoizedFn: Function): Function => {\n  let index: number = STATIC_PROPERTIES_TO_PASS_LENGTH,\n      property: string;\n\n  while (index--) {\n    property = STATIC_PROPERTIES_TO_PASS[index];\n\n    if (originalFunction[property]) {\n      memoizedFn[property] = originalFunction[property];\n    }\n  }\n\n  return memoizedFn;\n};\n\n/**\n * @private\n *\n * @function compose\n *\n * @description\n * method to compose functions and return a single function\n *\n * @param {...Array<function>} functions the functions to compose\n * @returns {function(...Array<*>): *} the composed function\n */\nexport const compose = (...functions: Array<Function>): Function => {\n  return functions.reduce((f: Function, g: Function): Function => {\n    return (...args: Array<any>): any => {\n      return f(g(...args));\n    };\n  });\n};\n\n/**\n * @private\n *\n * @function every\n *\n * @description\n * faster version of determining every item in array matches fn check\n *\n * @param {Array<*>} array array to test\n * @param {function} fn fn to test each item against\n * @returns {boolean} do all values match\n */\nexport const every = (array: Array<any>, fn: Function) => {\n  if (!array.length) {\n    return true;\n  }\n\n  let index: number = array.length;\n\n  while (index--) {\n    if (!fn(array[index], index)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n * @private\n *\n * @function splice\n *\n * @description\n * faster version of splicing a single item from the array\n *\n * @param {Array<*>} array array to splice from\n * @param {number} startingIndex index to splice at\n * @returns {Array<*>} array minus the item removed\n */\nexport const splice = (array: Array<any>, startingIndex: number): Array<any> => {\n  if (!array.length) {\n    return array;\n  }\n\n  let index: number = startingIndex - 1;\n\n  while (++index < array.length) {\n    array[index] = array[index + 1];\n  }\n\n  array.length -= 1;\n\n  return array;\n};\n\n/**\n * @private\n *\n * @function unshift\n *\n * @description\n * faster version of unshifting a single item into an array\n *\n * @param {Array<*>} array array to unshift into\n * @param {*} item item to unshift into array\n * @returns {*} the item just added to the array\n */\nexport const unshift = (array: Array<any>, item: any): any => {\n  let index: number = array.length;\n\n  while (index--) {\n    array[index + 1] = array[index];\n  }\n\n  return array[0] = item;\n};\n\n/**\n * @private\n *\n * @function isCache\n *\n * @description\n * is the object passed an instance of the native Cache implementation\n *\n * @param {*} object object to test\n * @returns {boolean} is the object an instance of Cache\n */\nexport const isCache = (object: any): boolean => {\n  return !!object[CACHE_IDENTIFIER];\n};\n\n/**\n * @private\n *\n * @function createCurriableOptionMethod\n *\n * @description\n * create a method that will curry moize with the option + value passed\n *\n * @param {function} fn the method to call\n * @param {string} option the name of the option to apply\n * @param {*} value the value to assign to option\n * @returns {function} the moizer with the option pre-applied\n */\nexport const createCurriableOptionMethod = (fn: Function, option: string): Function => {\n  return function(value: any): Function {\n    return fn({\n      [option]: value\n    });\n  };\n};\n\n/**\n * @private\n *\n * @function createPluckFromInstanceList\n *\n * @description\n * get a property from the list on the cache\n *\n * @param {{list: Array<Object>}} cache cache whose list to map over\n * @param {string} key key to pluck from list\n * @returns {Array<*>} array of values plucked at key\n */\nexport const createPluckFromInstanceList = (cache: Cache, key: string): Function => {\n  return !isCache(cache) ? () => {} : (): Array<any> => {\n    return cache.list.map((item: ListItem) => {\n      return item[key];\n    });\n  };\n};\n\n/**\n * @private\n *\n * @function getFunctionNameViaRegexp\n *\n * @description\n * use regexp match on stringified function to get the function name\n *\n * @param {function} fn function to get the name of\n * @returns {string} function name\n */\nexport const getFunctionNameViaRegexp = (fn: Function): string => {\n  const match: ?Array<string> = fn.toString().match(FUNCTION_NAME_REGEXP);\n\n  return match ? match[1] : '';\n};\n\n/**\n * @private\n *\n * @function getFunctionName\n *\n * @description\n * get the function name, either from modern property or regexp match,\n * falling back to generic string\n *\n * @param {function} fn function to get the name of\n * @returns {string} function name\n */\nexport const getFunctionName = (fn: Function): string => {\n  return fn.displayName || fn.name || getFunctionNameViaRegexp(fn) || FUNCTION_TYPEOF;\n};\n\n/**\n * @private\n *\n * @function isArrayFallback\n *\n * @description\n * provide fallback for native Array.isArray test\n *\n * @param {*} object object to test if it is an array\n * @returns {boolean} is the object passed an array or not\n */\nexport const isArrayFallback = function(object: any): boolean {\n  return toString.call(object) === ARRAY_OBJECT_CLASS;\n};\n\n/**\n * @private\n *\n * @function isArray\n *\n * @description\n * isArray function to use internally, either the native one or fallback\n *\n * @param {*} object object to test if it is an array\n * @returns {boolean} is the object passed an array or not\n */\nexport const isArray = Array.isArray || isArrayFallback;\n\n/**\n * @private\n *\n * @function isComplexObject\n *\n * @description\n * is the object passed a complex object\n *\n * @param {*} object object to test if it is complex\n * @returns {boolean} is it a complex object\n */\nexport const isComplexObject = (object: any): boolean => {\n  return !!object && typeof object === OBJECT_TYPEOF;\n};\n\n/**\n * @private\n *\n * @function isFunction\n *\n * @description\n * is the object passed a function or not\n *\n * @param {*} object object to test\n * @returns {boolean} is it a function\n */\nexport const isFunction = (object: any): boolean => {\n  return typeof object === FUNCTION_TYPEOF;\n};\n\n/**\n * @private\n *\n * @function isPlainObject\n *\n * @description\n * is the object passed a plain object or not\n *\n * @param {*} object object to test\n * @returns {boolean} is it a plain object\n */\nexport const isPlainObject = (object: any): boolean => {\n  return isComplexObject(object) && object.constructor === Object;\n};\n\n/**\n * @private\n *\n * @function isValueObjectOrArray\n *\n * @description\n * check if the object is actually an object or array\n *\n * @param {*} object object to test\n * @returns {boolean} is the object an object or array\n */\nexport const isValueObjectOrArray = (object: any): boolean => {\n  return isComplexObject(object) && every(GOTCHA_OBJECT_CLASSES, (Class) => {\n    return !(object instanceof Class);\n  });\n};\n\n/**\n * @private\n *\n * @function customReplacer\n *\n * @description\n * custom replacer for the stringify function\n *\n * @param {string} key key in json object\n * @param {*} value value in json object\n * @returns {*} if function then toString of it, else the value itself\n */\nexport const customReplacer = (key: string, value: any): any => {\n  return isFunction(value) ? `${value}` : value;\n};\n\n/**\n * @private\n *\n * @function decycle\n *\n * @description\n * ES2015-ified version of cycle.decyle\n *\n * @param {*} object object to stringify\n * @returns {string} stringified value of object\n */\nexport const decycle = (object: any): string => {\n  let cache: Cache = new Cache();\n\n  /**\n   * @private\n   *\n   * @function coalesceCircularReferences\n   *\n   * @description\n   * recursive method to replace any circular references with a placeholder\n   *\n   * @param {*} value value in object to decycle\n   * @param {string} path path to reference\n   * @returns {*} clean value\n   */\n  const coalesceCircularReferences = (value: any, path: string): any => {\n    if (!isValueObjectOrArray(value)) {\n      return value;\n    }\n\n    if (cache.has(value)) {\n      return {\n        $ref: cache.get(value)\n      };\n    }\n\n    cache.set(value, path);\n\n    if (isArray(value)) {\n      return value.map((item, itemIndex) => {\n        return coalesceCircularReferences(item, `${path}[${itemIndex}]`);\n      });\n    }\n\n    return keys(value).reduce((object, name) => {\n      object[name] = coalesceCircularReferences(value[name], `${path}[${JSON.stringify(name)}]`);\n\n      return object;\n    }, {});\n  };\n\n  return coalesceCircularReferences(object, '$');\n};\n\n/**\n * @private\n *\n * @function deleteItemFromCache\n *\n * @description\n * remove an item from cache\n *\n * @param {Cache} cache caching mechanism for method\n * @param {*} key key to delete\n * @param {boolean} [isKeyLastItem=false] should the key be the last item in the LRU list\n */\nexport const deleteItemFromCache = (cache: Cache, key: any, isKeyLastItem: boolean = false) => {\n  if (isKeyLastItem && isCache(cache)) {\n    key = cache.list[cache.list.length - 1].key;\n  }\n\n  if (cache.has(key)) {\n    cache.delete(key);\n  }\n};\n\n/**\n * @private\n *\n * @function isKeyShallowEqualWithArgs\n *\n * @description\n * is the value passed shallowly equal with the args\n *\n * @param {*} value the value to compare\n * @param {Array<*>} args the args to test\n * @returns {boolean} are the args shallow equal to the value\n */\nexport const isKeyShallowEqualWithArgs = (value: any, args: Array<any>): boolean => {\n  return value.isMultiParamKey && value.key.length === args.length && every(args, (arg, index) => {\n    return arg === value.key[index];\n  });\n};\n\n/**\n * @private\n *\n * @function getMultiParamKey\n *\n * @description\n * get the multi-parameter key that either matches a current one in state or is the same as the one passed\n *\n * @param {Cache} cache cache to compare args to\n * @param {Array<*>} args arguments passed to moize get key\n * @returns {Array<*>} either a matching key in cache or the same key as the one passed\n */\nexport const getMultiParamKey = (cache: Cache, args: Array<any>): Array<any> => {\n  if (cache.lastItem && isKeyShallowEqualWithArgs(cache.lastItem, args)) {\n    return cache.lastItem.key;\n  }\n\n  const iterator = cache.getKeyIterator();\n\n  let iteration: Object;\n\n  while ((iteration = iterator.next()) && !iteration.done) {\n    if (isKeyShallowEqualWithArgs(iteration, args)) {\n      return iteration.key;\n    }\n  }\n\n  // $FlowIgnore ok to add key to array object\n  args.isMultiParamKey = true;\n\n  return args;\n};\n\n/**\n * @private\n *\n * @function createAddPropertiesToFunction\n *\n * @description\n * add the caching mechanism to the function passed and return the function\n *\n * @param {Cache} cache caching mechanism that has get / set / has methods\n * @param {function} originalFunction function to get the name of\n * @param {Options} options the options for the given memoized function\n * @returns {function(function): function} method that has cache mechanism added to it\n */\nexport const createAddPropertiesToFunction = (cache: Cache, originalFunction: Function, options: Options): Function => {\n  return (fn: Function): Function => {\n    fn.cache = cache;\n    fn.displayName = `Memoized(${getFunctionName(originalFunction)})`;\n    fn.isMemoized = true;\n    fn.options = options;\n    fn.originalFunction = originalFunction;\n\n    /**\n     * @private\n     *\n     * @function add\n     *\n     * @description\n     * manually add an item to cache if the key does not already exist\n     *\n     * @param {*} key key to use in cache\n     * @param {*} value value to assign to key\n     */\n    fn.add = (key, value) => {\n      if (!cache.has(key) && getMultiParamKey(cache, key) === key) {\n        cache.set(key, value);\n      }\n    };\n\n    /**\n     * @private\n     *\n     * @function clear\n     *\n     * @description\n     * clear the current cache for this method\n     */\n    fn.clear = () => {\n      cache.clear();\n    };\n\n    /**\n     * @private\n     *\n     * @function delete\n     *\n     * @description\n     * delete the cache for the key passed for this method\n     *\n     * @param {Array<*>} args combination of args to remove from cache\n     */\n    fn.delete = (...args: Array<any>) => {\n      const key = args.length === 1 && args[0].isMultiParamKey ? args[0] : getMultiParamKey(cache, args);\n\n      deleteItemFromCache(cache, key);\n    };\n\n    /**\n     * @private\n     *\n     * @function keys\n     *\n     * @description\n     * get the list of keys currently in cache\n     *\n     * @returns {Array<*>}\n     */\n    fn.keys = createPluckFromInstanceList(cache, 'key');\n\n    /**\n     * @private\n     *\n     * @function values\n     *\n     * @description\n     * get the list of values currently in cache\n     *\n     * @returns {Array<*>}\n     */\n    fn.values = createPluckFromInstanceList(cache, 'value');\n\n    return addStaticPropertiesToFunction(originalFunction, fn);\n  };\n};\n\n/**\n * @private\n *\n * @function isFiniteAndPositive\n *\n * @description\n * is the number passed finite and positive\n *\n * @param {number} number number to test for finiteness and positivity\n * @returns {boolean} is the number finite and positive\n */\nexport const isFiniteAndPositive = (number: number): boolean => {\n  return number === ~~number && number > 0;\n};\n\n/**\n * @private\n *\n * @function getIndexOfKey\n *\n * @description\n * get the index of the key in the map\n *\n * @param {Cache} cache cache to iterate over\n * @param {*} key key to find in list\n * @returns {number} index location of key in list\n */\nexport const getIndexOfKey = (cache: Cache, key: any): number => {\n  const iterator: KeyIterator = cache.getKeyIterator();\n\n  let iteration: Object;\n\n  while ((iteration = iterator.next()) && !iteration.done) {\n    if (iteration.key === key) {\n      return iteration.index;\n    }\n  }\n\n  return -1;\n};\n\n/**\n * @private\n *\n * @function stringify\n *\n * @description\n * stringify with a custom replacer if circular, else use standard JSON.stringify\n *\n * @param {*} value value to stringify\n * @param {function} [replacer] replacer to used in stringification\n * @returns {string} the stringified version of value\n */\nexport const stringify = (value: any, replacer: ?Function) => {\n  try {\n    return jsonStringify(value, replacer);\n  } catch (exception) {\n    return jsonStringify(decycle(value), replacer);\n  }\n};\n\n/**\n * @private\n *\n * @function getStringifiedArgument\n *\n * @description\n * get the stringified version of the argument passed\n *\n * @param {*} arg argument to stringify\n * @param {function} [replacer] replacer to used in stringification\n * @returns {string}\n */\nexport const getStringifiedArgument = (arg: any, replacer: ?Function) => {\n  return isComplexObject(arg) ? stringify(arg, replacer) : arg;\n};\n\n/**\n * @private\n *\n * @function createArgumentSerializer\n *\n * @description\n * create the internal argument serializer based on the options passed\n *\n * @param {boolean} serializeFunctions should functions be included in the serialization\n * @param {number} maxArgs the cap on the number of arguments used in serialization\n * @returns {function(...Array<*>): string} argument serialization method\n */\nexport const createArgumentSerializer = (\n  serializeFunctions: boolean,\n  maxArgs: number\n): Function => {\n  const replacer: ?Function = serializeFunctions ? customReplacer : null;\n  const hasMaxArgs: boolean = isFiniteAndPositive(maxArgs);\n\n  return (args: Array<any>): string => {\n    const length: number = hasMaxArgs ? maxArgs : args.length;\n\n    let index: number = -1,\n        key: string = '|';\n\n    while (++index < length) {\n      key += `${getStringifiedArgument(args[index], replacer)}|`;\n    }\n\n    return key;\n  };\n};\n\n/**\n * @private\n *\n * @function getSerializerFunction\n *\n * @description\n * based on the options passed, either use the serializer passed or generate the internal one\n *\n * @param {function} [serializerFromOptions] serializer function passed into options\n * @param {boolean} serializeFunctions should functions be included in the serialization\n * @param {number} maxArgs the cap on the number of arguments used in serialization\n * @returns {function} the function to use in serializing the arguments\n */\nexport const getSerializerFunction = (\n  serializerFromOptions: ?Function,\n  serializeFunctions: boolean,\n  maxArgs: number\n): Function => {\n  // $FlowIgnore\n  return isFunction(serializerFromOptions) ? serializerFromOptions :\n    createArgumentSerializer(serializeFunctions, maxArgs);\n};\n\n/**\n * @private\n *\n * @function createGetCacheKey\n *\n * @description\n * get the key used for storage in the method's cache\n *\n * @param {Cache} cache cache where keys are stored\n * @param {boolean} serialize should the arguments be serialized into a string\n * @param {function} serializerFromOptions method used to serialize keys into a string\n * @param {boolean} serializeFunctions should functions be converted to string in serialization\n * @param {number} maxArgs the maximum number of arguments to use in the serialization\n * @returns {function(Array<*>): *}\n */\nexport const createGetCacheKey = (\n  cache: Cache,\n  serialize: boolean,\n  serializerFromOptions: ?Function,\n  serializeFunctions: boolean,\n  maxArgs: number\n): Function => {\n  if (serialize) {\n    const serializeArguments = getSerializerFunction(serializerFromOptions, serializeFunctions, maxArgs);\n\n    return (args: Array<any>): any => {\n      return serializeArguments(args);\n    };\n  }\n\n  if (isFiniteAndPositive(maxArgs)) {\n    return (args: Array<any>): any => {\n      return args.length > 1 ? getMultiParamKey(cache, args.slice(0, maxArgs)) : args[0];\n    };\n  }\n\n  return (args: Array<any>): any => {\n    return args.length > 1 ? getMultiParamKey(cache, args) : args[0];\n  };\n};\n\n/**\n * @private\n *\n * @function setExpirationOfCache\n *\n * @description\n * create function to set the cache to expire after the maxAge passed (coalesced to 0)\n *\n * @param {number} maxAge number in ms to wait before expiring the cache\n * @returns {function(Cache, Array<*>): void} setExpirationOfCache method\n */\nexport const createSetExpirationOfCache = (maxAge: number) => {\n  return (cache: Cache, key: Array<any>) => {\n    setTimeout(() => {\n      deleteItemFromCache(cache, key);\n    }, maxAge);\n  };\n};\n\n/**\n * @private\n *\n * @function createPromiseRejecter\n *\n * @description\n * create method that will reject the promise and delete the key from cache\n *\n * @param {Cache} cache cache to update\n * @param {*} key key to delete from cache\n * @param {function} PromiseLibrary the promise library used\n * @returns {function} the rejecter function for the promise\n */\nexport const createPromiseRejecter = (\n  cache: Cache,\n  key: any,\n  PromiseLibrary: Function\n): Function => {\n  return (exception: Error) => {\n    cache.delete(key);\n\n    return PromiseLibrary.reject(exception);\n  };\n};\n\n/**\n * @private\n *\n * @function createPromiseResolver\n *\n * @description\n * create method that will resolve the promise and update the key in cache\n *\n * @param {Cache} cache cache to update\n * @param {*} key key to update in cache\n * @param {boolean} hasMaxAge should the cache expire after some time\n * @param {function} setExpirationOfCache function to set the expiration of cache\n * @param {function} PromiseLibrary the promise library used\n * @returns {function} the resolver function for the promise\n */\nexport const createPromiseResolver = (\n  cache: Cache,\n  key: any,\n  hasMaxAge: boolean,\n  setExpirationOfCache: Function,\n  PromiseLibrary: Function\n): Function => {\n  return (resolvedValue: any) => {\n    cache.updateItem(key, PromiseLibrary.resolve(resolvedValue));\n\n    if (hasMaxAge) {\n      setExpirationOfCache(cache, key);\n    }\n\n    return resolvedValue;\n  };\n};\n\n/**\n * @private\n *\n * @function createSetNewCachedValue\n *\n * @description\n * assign the new value to the key in the functions cache and return the value\n *\n * @param {Cache} cache the cache to assign the value to at key\n * @param {boolean} isPromise is the value a promise or not\n * @param {number} maxAge how long should the cache persist\n * @param {number} maxSize the maximum number of values to store in cache\n * @param {Function} PromiseLibrary the library to use for resolve / reject\n * @returns {function(function, *, *): *} value just stored in cache\n */\nexport const createSetNewCachedValue = (\n  cache: Cache,\n  isPromise: boolean,\n  maxAge: number,\n  maxSize: number,\n  PromiseLibrary: Function\n): Function => {\n  const hasMaxAge: boolean = isFiniteAndPositive(maxAge);\n  const hasMaxSize: boolean = isFiniteAndPositive(maxSize);\n  const setExpirationOfCache: Function = createSetExpirationOfCache(maxAge);\n\n  if (isPromise) {\n    return (key: any, value: any): Promise<any> => {\n      const promiseResolver = createPromiseResolver(cache, key, hasMaxAge, setExpirationOfCache, PromiseLibrary);\n      const promiseRejecter = createPromiseRejecter(cache, key, PromiseLibrary);\n\n      const handler = value.then(promiseResolver, promiseRejecter);\n\n      cache.set(key, handler);\n\n      if (hasMaxSize && cache.size > maxSize) {\n        deleteItemFromCache(cache, undefined, true);\n      }\n\n      return handler;\n    };\n  }\n\n  return (key: any, value: any): any => {\n    cache.set(key, value);\n\n    if (hasMaxAge) {\n      setExpirationOfCache(cache, key);\n    }\n\n    if (hasMaxSize && cache.size > maxSize) {\n      deleteItemFromCache(cache, undefined, true);\n    }\n\n    return value;\n  };\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils.js","// @flow\n\n// cache\nimport Cache from './Cache';\n\n// constants\nimport {\n  INFINITY,\n  INVALID_FIRST_PARAMETER_ERROR,\n  NO_PROMISE_LIBRARY_EXISTS_ERROR_MESSAGE\n} from './constants';\n\n// types\nimport type {\n  Options\n} from './types';\n\n// utils\nimport {\n  compose,\n  createAddPropertiesToFunction,\n  createCurriableOptionMethod,\n  createGetCacheKey,\n  createSetNewCachedValue,\n  isFunction,\n  isPlainObject\n} from './utils';\n\n/**\n * @module moize\n */\n\n/**\n * @constant {{isPromise: true}} PROMISE_OPTIONS\n */\nconst PROMISE_OPTIONS = {\n  isPromise: true\n};\n\n/**\n * @constant {{maxArgs: number, serialize: boolean, serializeFunctions: boolean}} REACT_OPTIONS\n */\nconst REACT_OPTIONS = {\n  maxArgs: 2,\n  serialize: true,\n  serializeFunctions: true\n};\n\n/**\n * @constant {{serialize: boolean}} SERIALIZE_OPTIONS\n */\nconst SERIALIZE_OPTIONS = {\n  serialize: true\n};\n\n/**\n * @function moize\n *\n * @description\n * store cached values returned from calling method with arguments to avoid reprocessing data from same arguments\n *\n * @example\n * import moize from 'moize';\n *\n * // standard implementation\n * const fn = (foo, bar) => {\n *  return `${foo} ${bar}`;\n * };\n * const memoizedFn = moize(fn);\n *\n * // implementation with options\n * const fn = async (id) => {\n *  return get(`http://foo.com/${id}`);\n * };\n * const memoizedFn = moize(fn, {\n *  isPromise: true,\n *  maxSize: 5\n * });\n *\n * @param {function} functionOrComposableOptions method to memoize\n * @param {Options} [passedOptions={}] options to customize how the caching is handled\n * @param {Cache} [passedOptions.cache=new Cache()] caching mechanism to use for method\n * @param {boolean} [passedOptions.isPromise=false] is the function return expected to be a promise to resolve\n * @param {number} [passedOptions.maxAge=Infinity] the maximum age the value should persist in cache\n * @param {number} [passedOptions.maxArgs=Infinity] the maximum number of arguments to be used in serializing the keys\n * @param {number} [passedOptions.maxSize=Infinity] the maximum size of the cache to retain\n * @param {function} [passedOptions.promiseLibrary=Promise] promise library to use for resolution / rejection\n * @param {function} [passedOptions.serializeFunctions=false] should function parameters be serialized as well\n * @param {function} [passedOptions.serializer] method to serialize arguments with for cache storage\n * @returns {Function} higher-order function which either returns from cache or newly-computed value\n */\nconst moize = function(functionOrComposableOptions: (Function|Object), passedOptions: Options = {}): any {\n  if (isPlainObject(functionOrComposableOptions)) {\n    return function(fn: Function, otherOptions: Options = {}): Function {\n      return moize(fn, {\n        // $FlowIgnore functionOrComposableOptions is object of options\n        ...functionOrComposableOptions,\n        ...otherOptions\n      });\n    };\n  }\n\n  if (!isFunction(functionOrComposableOptions)) {\n    throw new TypeError(INVALID_FIRST_PARAMETER_ERROR);\n  }\n\n  const isComposed: boolean = functionOrComposableOptions.isMemoized;\n  // $FlowIgnore the value of the property is a function\n  const fn: Function = isComposed ? functionOrComposableOptions.originalFunction : functionOrComposableOptions;\n  const options: Object = !isComposed ? passedOptions : {\n    ...functionOrComposableOptions.options,\n    ...passedOptions\n  };\n\n  const {\n    cache = new Cache(),\n    isPromise = false,\n    maxAge = INFINITY,\n    maxArgs = INFINITY,\n    maxSize = INFINITY,\n    promiseLibrary = Promise,\n    serialize = false,\n    serializeFunctions = false,\n    serializer\n  } = options;\n\n  if (isPromise && !promiseLibrary) {\n    throw new ReferenceError(NO_PROMISE_LIBRARY_EXISTS_ERROR_MESSAGE);\n  }\n\n  const addPropertiesToFunction: Function = createAddPropertiesToFunction(cache, fn, options);\n  const getCacheKey: Function = createGetCacheKey(cache, serialize, serializer, serializeFunctions, maxArgs);\n  const setNewCachedValue: Function = createSetNewCachedValue(cache, isPromise, maxAge, maxSize, promiseLibrary);\n\n  let key: any;\n\n  /**\n   * @private\n   *\n   * @function memoizedFunction\n   *\n   * @description\n   * higher-order function which either returns from cache or stores newly-computed value and returns it\n   *\n   * @param {Array<*>} args arguments passed to method\n   * @returns {any} value resulting from executing of fn passed to memoize\n   */\n  const memoizedFunction = function(...args: Array<any>): any {\n    key = getCacheKey(args);\n\n    return cache.has(key) ? cache.get(key) : setNewCachedValue(key, fn.apply(this, args));\n  };\n\n  return addPropertiesToFunction(memoizedFunction);\n};\n\nmoize.compose = compose;\nmoize.maxAge = createCurriableOptionMethod(moize, 'maxAge');\nmoize.maxArgs = createCurriableOptionMethod(moize, 'maxArgs');\nmoize.maxSize = createCurriableOptionMethod(moize, 'maxSize');\nmoize.promise = moize(PROMISE_OPTIONS);\nmoize.react = moize(REACT_OPTIONS);\nmoize.serialize = moize(SERIALIZE_OPTIONS);\nmoize.simple = moize.maxSize(1);\n\nexport default moize;\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js"],"sourceRoot":""}