'use strict';

exports.__esModule = true;
exports.setGlobalOptions = exports.createSetStyleTag = exports.createSetLinkTag = exports.createSetCorrectTag = exports.createRemoveTagFromHead = exports.createAssignRefToInstance = exports.createComponentWillUnmount = exports.createComponentDidUpdate = exports.createShouldComponentUpdate = exports.createComponentDidMount = exports.createComponentWillMount = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; // external dependencies


// local utils


var _isBoolean = require('lodash/isBoolean');

var _isBoolean2 = _interopRequireDefault(_isBoolean);

var _isNull = require('lodash/isNull');

var _isNull2 = _interopRequireDefault(_isNull);

var _moize = require('moize');

var _moize2 = _interopRequireDefault(_moize);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _cache = require('./cache');

var _constants = require('./constants');

var _transform = require('./transform');

var _utils = require('./utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var globalProperties = _extends({}, _constants.DEFAULT_REACT_STYLE_TAG_GLOBAL_PROPERTIES),
    hasBlobSupport = void 0,
    url = void 0;

var createComponentWillMount = exports.createComponentWillMount = function createComponentWillMount(instance) {
  /**
   * @function componentWillMount
   *
   * @description
   * just prior to mount, assign blob support if falsy and assign the instance id
   */
  return function () {
    var _instance$props = instance.props,
        children = _instance$props.children,
        id = _instance$props.id;


    if (!hasBlobSupport) {
      url = (0, _utils.getUrl)();

      if (url) {
        hasBlobSupport = (0, _utils.getHasBlobSupport)();
      }
    }

    instance.id = (0, _cache.createIdForTag)(id, children);
  };
};

var createComponentDidMount = exports.createComponentDidMount = function createComponentDidMount(instance) {
  /**
   * @function componentWillMount
   *
   * @description
   * on mount, set the correct tag based on local or global properties
   */
  return function () {
    instance.setCorrectTag();
  };
};

var createShouldComponentUpdate = exports.createShouldComponentUpdate = function createShouldComponentUpdate(instance) {
  /**
   * @function shouldComponentUpdate
   *
   * @description
   * prevent update of the component unless the children content has changed
   *
   * @param {string} nextChildren the incoming children
   * @returns {boolean} should the component update
   */
  return function (_ref) {
    var nextChildren = _ref.children;
    var children = instance.props.children;


    return children !== nextChildren;
  };
};

var createComponentDidUpdate = exports.createComponentDidUpdate = function createComponentDidUpdate(instance) {
  /**
   * @function componentDidUpdate
   *
   * @description
   * on component update, set the new children in the cache and set the new correct tag
   */
  return function () {
    var children = instance.props.children;


    (0, _cache.setCacheId)(instance.id, children);

    instance.setCorrectTag();
  };
};

var createComponentWillUnmount = exports.createComponentWillUnmount = function createComponentWillUnmount(instance) {
  /**
   * @function componentWillUnmount
   *
   * @description
   * just prior to mount, remove all appropriate tags from the head and ids from cache
   */
  return function () {
    instance.removeTagFromHead('link');
    instance.removeTagFromHead('style');

    if (!(0, _isNull2.default)(instance.id)) {
      (0, _cache.removeIdFromCache)(instance.id);
    }
  };
};

var createAssignRefToInstance = exports.createAssignRefToInstance = function createAssignRefToInstance(instance, refName) {
  /**
   * @function assignRefToInstance
   *
   * @description
   * assign the element passed to the instance at refName
   *
   * @param {HTMLElement} element the element to assign to the instance
   */
  return function (element) {
    instance[refName] = element;
  };
};

var createRemoveTagFromHead = exports.createRemoveTagFromHead = function createRemoveTagFromHead(instance) {
  /**
   * @function removeTagFromHead
   *
   * @description
   * remove the tagType from the document head if it exists
   *
   * @param {string} tagType
   */
  return function (tagType) {
    var tag = instance[tagType];

    if (tag) {
      document.head.removeChild(tag);

      instance[tagType] = null;
    }
  };
};

var createSetCorrectTag = exports.createSetCorrectTag = function createSetCorrectTag(instance) {
  /**
   * @function setCorrectTag
   *
   * @description
   * based on whether sourcemaps are requested, set either a link or style tag
   */
  return function () {
    var hasSourceMap = instance.props.hasSourceMap;


    if (!(0, _isNull2.default)(instance.id)) {
      var hasSourceMapGlobal = globalProperties.hasSourceMap;


      var hasSourceMapFinal = instance.getCoalescedPropsValue(hasSourceMap, hasSourceMapGlobal);

      if (hasSourceMapFinal) {
        instance.setLinkTag();
      } else {
        instance.setStyleTag();
      }
    }
  };
};

var createSetLinkTag = exports.createSetLinkTag = function createSetLinkTag(instance) {
  /**
   * @function setLinkTag
   *
   * @description
   * set the link tag with the prefixed / minified css text as a blob and move to the document head
   */
  return function () {
    var _instance$props2 = instance.props,
        children = _instance$props2.children,
        doNotPrefix = _instance$props2.doNotPrefix,
        isMinified = _instance$props2.isMinified;


    (0, _utils.throwErrorIfIsNotText)(children);

    instance.removeTagFromHead('style');

    if (!hasBlobSupport) {
      throw new ReferenceError(_constants.NO_BLOB_SUPPORT_ERROR);
    }

    var doNotPrefixGlobal = globalProperties.doNotPrefix,
        isMinifiedGlobal = globalProperties.isMinified;


    var doNotPrefixFinal = instance.getCoalescedPropsValue(doNotPrefix, doNotPrefixGlobal);
    var isMinifiedFinal = instance.getCoalescedPropsValue(isMinified, isMinifiedGlobal);
    var transformedCss = (0, _transform.getTransformedCss)(children, doNotPrefixFinal, isMinifiedFinal);

    var link = instance.link;
    var blob = new window.Blob([transformedCss], {
      type: 'text/css'
    });

    link.href = url.createObjectURL(blob);

    document.head.appendChild(link);
  };
};

var createSetStyleTag = exports.createSetStyleTag = function createSetStyleTag(instance) {
  /**
   * @function setStyleTag
   *
   * @description
   * set the style tag with the prefixed / minified css text and move to the document head
   */
  return function () {
    var _instance$props3 = instance.props,
        children = _instance$props3.children,
        doNotPrefix = _instance$props3.doNotPrefix,
        isMinified = _instance$props3.isMinified;
    var doNotPrefixGlobal = globalProperties.doNotPrefix,
        isMinifiedGlobal = globalProperties.isMinified;


    (0, _utils.throwErrorIfIsNotText)(children);

    instance.removeTagFromHead('link');

    var doNotPrefixFinal = instance.getCoalescedPropsValue(doNotPrefix, doNotPrefixGlobal);
    var isMinifiedFinal = instance.getCoalescedPropsValue(isMinified, isMinifiedGlobal);

    var style = instance.style;

    style.textContent = (0, _transform.getTransformedCss)(children, doNotPrefixFinal, isMinifiedFinal);

    document.head.appendChild(style);
  };
};

/**
 * @function setGlobalOptions
 *
 * @description
 * set the global options for all instances of Style
 *
 * @param {object} options
 * @param {boolean} [options.doNotPrefix]
 * @param {boolean} [options.hasSourceMap]
 * @param {boolean} [options.isMinified]
 * @returns {Object} globalProperties
 */
var setGlobalOptions = exports.setGlobalOptions = function setGlobalOptions(options) {
  Object.keys(options).forEach(function (option) {
    if (globalProperties.hasOwnProperty(option)) {
      if (!(0, _isBoolean2.default)(options[option])) {
        throw new TypeError(option + ' must be a boolean value.');
      }

      globalProperties[option] = options[option];
    }
  });

  return globalProperties;
};

var Style = function (_Component) {
  _inherits(Style, _Component);

  function Style() {
    var _temp, _this, _ret;

    _classCallCheck(this, Style);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.componentWillMount = createComponentWillMount(_this), _this.componentDidMount = createComponentDidMount(_this), _this.shouldComponentUpdate = createShouldComponentUpdate(_this), _this.componentDidUpdate = createComponentDidUpdate(_this), _this.componentWillUnmount = createComponentWillUnmount(_this), _this.hasBlobSupport = false, _this.id = null, _this.link = null, _this.style = null, _this.getCoalescedPropsValue = (0, _moize2.default)(_transform.getCoalescedPropsValue), _this.removeTagFromHead = createRemoveTagFromHead(_this), _this.setCorrectTag = createSetCorrectTag(_this), _this.setLinkRef = createAssignRefToInstance(_this, 'link'), _this.setLinkTag = createSetLinkTag(_this), _this.setStyleRef = createAssignRefToInstance(_this, 'style'), _this.setStyleTag = createSetStyleTag(_this), _temp), _possibleConstructorReturn(_this, _ret);
  }

  // lifecycle methods


  // instance values


  // static methods


  // instance methods


  Style.prototype.render = function render() {
    if ((0, _isNull2.default)(this.id)) {
      return null;
    }

    var _props = this.props,
        children = _props.children,
        doNotPrefixIgnored = _props.doNotPrefix,
        hasSourceMap = _props.hasSourceMap,
        idIgnored = _props.id,
        isMinifiedIgnored = _props.isMinified,
        otherProps = _objectWithoutProperties(_props, ['children', 'doNotPrefix', 'hasSourceMap', 'id', 'isMinified']);

    var hasSourceMapGlobal = globalProperties.hasSourceMap;


    var hasSourceMapFinal = this.getCoalescedPropsValue(hasSourceMap, hasSourceMapGlobal);

    if (hasSourceMapFinal && hasBlobSupport) {
      return _react2.default.createElement('link', _extends({
        id: this.id,
        ref: this.setLinkRef,
        rel: 'stylesheet'
      }, otherProps));
    }

    return _react2.default.createElement(
      'style',
      _extends({
        id: this.id,
        ref: this.setStyleRef
      }, otherProps),
      children
    );
  };

  return Style;
}(_react.Component);

Style.propTypes = {
  children: _react.PropTypes.node,
  doNotPrefix: _react.PropTypes.bool,
  hasSourceMap: _react.PropTypes.bool,
  id: _react.PropTypes.string,
  isMinified: _react.PropTypes.bool
};
Style.setGlobalOptions = setGlobalOptions;
exports.default = Style;